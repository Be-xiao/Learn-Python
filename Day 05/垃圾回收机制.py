# 垃圾回收机制（了解）

# 什么是垃圾回收机制
# 垃圾回收机制（简称GC）是Python解释器自带一种机制，专门回收不可用的变量值所占用的内存空间

# 变量 x = 10,在内存中栈区域堆区的存放情况
# 栈区：存放变量名与内存地址的对于关系，所以可以简单理解为：变量名存内存地址
# 堆区：存放的是变量值

# 强调:只站在变量名的角度去谈一件事
# 变量名的赋值 (x = y), 还有变量名的传参（print(x)）,传递的都是引用=》栈区的数据，
# 而栈区的数据是变量名与内存地址的对应关系，或者说是对应值的引用
# Python是引用传递
# 示例一：
x = 10
y = 20
x = y
# 示例二：
l = [111, 'eee', '父亲']
l1 = [2222, 333.56, 'ddd']
l2 = l
l[0] = 'nickel'
print(l)
print(l2)

# 1、计数引用
x = 10  # 直接引用
print(id(x))
print(x)

l = ['a', x]  # 间接引用
print(id(l[1]))
print(l[1])

d = {"mm": x}  # 间接引用
print(id(d["mm"]))

x = 10
l = ['a', 'b', x]  # l = ['a'的内存地址，‘b’的内存地址，'10'的内存地址]
x = 123
print(l[2])

# 2、标记清楚
# 通俗的讲就是：
# 栈区相当于'根'，凡是从根出发可以访达（直接或间接引用）的，都称之为“有根之人”，有根之人当活，无根之人当死

# 循环引用->导致内存泄露
l1 = [111, ]
l2 = [222, ]
print(l1)
print(l2)

l1.append(l2)  # l1=[值111的内存地址，l2列表的内存地址]
print(id(l1), id(l2))
print(l1)
print(id(l1[1]))
l2.append(l1)  # l2=[值222的内存地址，l1列表的内存地址]
print(l2)
del l1
print(l2[1])
del l2

# 3、分代回收
# 新生代=》青春代=》老年代
# 分代回收在一定程度上会浪费空间，这无可避免，没有十全十美的解决方案

